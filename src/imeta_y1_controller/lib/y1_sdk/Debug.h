// Generated by gencpp from file y1_sdk/Debug.msg
// DO NOT EDIT!


#ifndef Y1_SDK_MESSAGE_DEBUG_H
#define Y1_SDK_MESSAGE_DEBUG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace y1_sdk
{
template <class ContainerAllocator>
struct Debug_
{
  typedef Debug_<ContainerAllocator> Type;

  Debug_()
    : header()
    , pos()
    , vel()
    , acc()
    , jerk()
    , feedforward_torque()
    , gravity_torque()
    , coriolis_torque()
    , friction_torque()
    , inertia_torque()
    , rls_comp_torque()
    , pid_comp_torque()
    , dob_comp_torque()
    , payload_comp_gravity_torque()
    , payload_comp_inertia_torque()
    , mass_rls(0.0)
    , T_traj_final(0.0)
    , Tv(0.0)
    , Ta(0.0)
    , Tj(0.0)
    , max_joint_delta(0.0)  {
    }
  Debug_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , pos(_alloc)
    , vel(_alloc)
    , acc(_alloc)
    , jerk(_alloc)
    , feedforward_torque(_alloc)
    , gravity_torque(_alloc)
    , coriolis_torque(_alloc)
    , friction_torque(_alloc)
    , inertia_torque(_alloc)
    , rls_comp_torque(_alloc)
    , pid_comp_torque(_alloc)
    , dob_comp_torque(_alloc)
    , payload_comp_gravity_torque(_alloc)
    , payload_comp_inertia_torque(_alloc)
    , mass_rls(0.0)
    , T_traj_final(0.0)
    , Tv(0.0)
    , Ta(0.0)
    , Tj(0.0)
    , max_joint_delta(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _pos_type;
  _pos_type pos;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _vel_type;
  _vel_type vel;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _acc_type;
  _acc_type acc;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _jerk_type;
  _jerk_type jerk;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _feedforward_torque_type;
  _feedforward_torque_type feedforward_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _gravity_torque_type;
  _gravity_torque_type gravity_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _coriolis_torque_type;
  _coriolis_torque_type coriolis_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _friction_torque_type;
  _friction_torque_type friction_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _inertia_torque_type;
  _inertia_torque_type inertia_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _rls_comp_torque_type;
  _rls_comp_torque_type rls_comp_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _pid_comp_torque_type;
  _pid_comp_torque_type pid_comp_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _dob_comp_torque_type;
  _dob_comp_torque_type dob_comp_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _payload_comp_gravity_torque_type;
  _payload_comp_gravity_torque_type payload_comp_gravity_torque;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _payload_comp_inertia_torque_type;
  _payload_comp_inertia_torque_type payload_comp_inertia_torque;

   typedef double _mass_rls_type;
  _mass_rls_type mass_rls;

   typedef double _T_traj_final_type;
  _T_traj_final_type T_traj_final;

   typedef double _Tv_type;
  _Tv_type Tv;

   typedef double _Ta_type;
  _Ta_type Ta;

   typedef double _Tj_type;
  _Tj_type Tj;

   typedef double _max_joint_delta_type;
  _max_joint_delta_type max_joint_delta;





  typedef boost::shared_ptr< ::y1_sdk::Debug_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::y1_sdk::Debug_<ContainerAllocator> const> ConstPtr;

}; // struct Debug_

typedef ::y1_sdk::Debug_<std::allocator<void> > Debug;

typedef boost::shared_ptr< ::y1_sdk::Debug > DebugPtr;
typedef boost::shared_ptr< ::y1_sdk::Debug const> DebugConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::y1_sdk::Debug_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::y1_sdk::Debug_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::y1_sdk::Debug_<ContainerAllocator1> & lhs, const ::y1_sdk::Debug_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.pos == rhs.pos &&
    lhs.vel == rhs.vel &&
    lhs.acc == rhs.acc &&
    lhs.jerk == rhs.jerk &&
    lhs.feedforward_torque == rhs.feedforward_torque &&
    lhs.gravity_torque == rhs.gravity_torque &&
    lhs.coriolis_torque == rhs.coriolis_torque &&
    lhs.friction_torque == rhs.friction_torque &&
    lhs.inertia_torque == rhs.inertia_torque &&
    lhs.rls_comp_torque == rhs.rls_comp_torque &&
    lhs.pid_comp_torque == rhs.pid_comp_torque &&
    lhs.dob_comp_torque == rhs.dob_comp_torque &&
    lhs.payload_comp_gravity_torque == rhs.payload_comp_gravity_torque &&
    lhs.payload_comp_inertia_torque == rhs.payload_comp_inertia_torque &&
    lhs.mass_rls == rhs.mass_rls &&
    lhs.T_traj_final == rhs.T_traj_final &&
    lhs.Tv == rhs.Tv &&
    lhs.Ta == rhs.Ta &&
    lhs.Tj == rhs.Tj &&
    lhs.max_joint_delta == rhs.max_joint_delta;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::y1_sdk::Debug_<ContainerAllocator1> & lhs, const ::y1_sdk::Debug_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace y1_sdk

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::y1_sdk::Debug_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::y1_sdk::Debug_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::y1_sdk::Debug_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::y1_sdk::Debug_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::y1_sdk::Debug_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::y1_sdk::Debug_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::y1_sdk::Debug_<ContainerAllocator> >
{
  static const char* value()
  {
    return "4e811e752e5f91d5a026b1b917a3be6c";
  }

  static const char* value(const ::y1_sdk::Debug_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x4e811e752e5f91d5ULL;
  static const uint64_t static_value2 = 0xa026b1b917a3be6cULL;
};

template<class ContainerAllocator>
struct DataType< ::y1_sdk::Debug_<ContainerAllocator> >
{
  static const char* value()
  {
    return "y1_sdk/Debug";
  }

  static const char* value(const ::y1_sdk::Debug_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::y1_sdk::Debug_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header\n"
"\n"
"# 运动相关\n"
"float64[] pos\n"
"float64[] vel \n"
"float64[] acc\n"
"float64[] jerk\n"
"\n"
"# 力矩相关\n"
"float64[] feedforward_torque\n"
"float64[] gravity_torque\n"
"float64[] coriolis_torque\n"
"float64[] friction_torque\n"
"float64[] inertia_torque\n"
"float64[] rls_comp_torque\n"
"float64[] pid_comp_torque\n"
"float64[] dob_comp_torque\n"
"float64[] payload_comp_gravity_torque\n"
"float64[] payload_comp_inertia_torque\n"
"float64 mass_rls\n"
"\n"
"# 规划时间相关\n"
"float64 T_traj_final\n"
"float64 Tv\n"
"float64 Ta\n"
"float64 Tj\n"
"float64 max_joint_delta\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::y1_sdk::Debug_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::y1_sdk::Debug_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.pos);
      stream.next(m.vel);
      stream.next(m.acc);
      stream.next(m.jerk);
      stream.next(m.feedforward_torque);
      stream.next(m.gravity_torque);
      stream.next(m.coriolis_torque);
      stream.next(m.friction_torque);
      stream.next(m.inertia_torque);
      stream.next(m.rls_comp_torque);
      stream.next(m.pid_comp_torque);
      stream.next(m.dob_comp_torque);
      stream.next(m.payload_comp_gravity_torque);
      stream.next(m.payload_comp_inertia_torque);
      stream.next(m.mass_rls);
      stream.next(m.T_traj_final);
      stream.next(m.Tv);
      stream.next(m.Ta);
      stream.next(m.Tj);
      stream.next(m.max_joint_delta);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Debug_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::y1_sdk::Debug_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::y1_sdk::Debug_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "pos[]" << std::endl;
    for (size_t i = 0; i < v.pos.size(); ++i)
    {
      s << indent << "  pos[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pos[i]);
    }
    s << indent << "vel[]" << std::endl;
    for (size_t i = 0; i < v.vel.size(); ++i)
    {
      s << indent << "  vel[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.vel[i]);
    }
    s << indent << "acc[]" << std::endl;
    for (size_t i = 0; i < v.acc.size(); ++i)
    {
      s << indent << "  acc[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.acc[i]);
    }
    s << indent << "jerk[]" << std::endl;
    for (size_t i = 0; i < v.jerk.size(); ++i)
    {
      s << indent << "  jerk[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.jerk[i]);
    }
    s << indent << "feedforward_torque[]" << std::endl;
    for (size_t i = 0; i < v.feedforward_torque.size(); ++i)
    {
      s << indent << "  feedforward_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.feedforward_torque[i]);
    }
    s << indent << "gravity_torque[]" << std::endl;
    for (size_t i = 0; i < v.gravity_torque.size(); ++i)
    {
      s << indent << "  gravity_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.gravity_torque[i]);
    }
    s << indent << "coriolis_torque[]" << std::endl;
    for (size_t i = 0; i < v.coriolis_torque.size(); ++i)
    {
      s << indent << "  coriolis_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.coriolis_torque[i]);
    }
    s << indent << "friction_torque[]" << std::endl;
    for (size_t i = 0; i < v.friction_torque.size(); ++i)
    {
      s << indent << "  friction_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.friction_torque[i]);
    }
    s << indent << "inertia_torque[]" << std::endl;
    for (size_t i = 0; i < v.inertia_torque.size(); ++i)
    {
      s << indent << "  inertia_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.inertia_torque[i]);
    }
    s << indent << "rls_comp_torque[]" << std::endl;
    for (size_t i = 0; i < v.rls_comp_torque.size(); ++i)
    {
      s << indent << "  rls_comp_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rls_comp_torque[i]);
    }
    s << indent << "pid_comp_torque[]" << std::endl;
    for (size_t i = 0; i < v.pid_comp_torque.size(); ++i)
    {
      s << indent << "  pid_comp_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_comp_torque[i]);
    }
    s << indent << "dob_comp_torque[]" << std::endl;
    for (size_t i = 0; i < v.dob_comp_torque.size(); ++i)
    {
      s << indent << "  dob_comp_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dob_comp_torque[i]);
    }
    s << indent << "payload_comp_gravity_torque[]" << std::endl;
    for (size_t i = 0; i < v.payload_comp_gravity_torque.size(); ++i)
    {
      s << indent << "  payload_comp_gravity_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.payload_comp_gravity_torque[i]);
    }
    s << indent << "payload_comp_inertia_torque[]" << std::endl;
    for (size_t i = 0; i < v.payload_comp_inertia_torque.size(); ++i)
    {
      s << indent << "  payload_comp_inertia_torque[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.payload_comp_inertia_torque[i]);
    }
    s << indent << "mass_rls: ";
    Printer<double>::stream(s, indent + "  ", v.mass_rls);
    s << indent << "T_traj_final: ";
    Printer<double>::stream(s, indent + "  ", v.T_traj_final);
    s << indent << "Tv: ";
    Printer<double>::stream(s, indent + "  ", v.Tv);
    s << indent << "Ta: ";
    Printer<double>::stream(s, indent + "  ", v.Ta);
    s << indent << "Tj: ";
    Printer<double>::stream(s, indent + "  ", v.Tj);
    s << indent << "max_joint_delta: ";
    Printer<double>::stream(s, indent + "  ", v.max_joint_delta);
  }
};

} // namespace message_operations
} // namespace ros

#endif // Y1_SDK_MESSAGE_DEBUG_H
